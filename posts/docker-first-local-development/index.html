<!DOCTYPE html>
<html>

<head>
    <title>Docker-first local development: building reproducible development environments - Brandon Hoffman</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&family=Russo+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/themes/default.css">
    <link id="theme-style" rel="stylesheet" type="text/css" href="">
    <!-- Add Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Custom styling for code blocks to ensure good contrast */
        pre[class*="language-"] {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 6px;
            padding: 1rem !important;
            margin: 1rem 0 !important;
            overflow-x: auto;
        }
        
        code[class*="language-"] {
            color: #e2e8f0 !important;
            background: transparent !important;
        }
        
        /* Dockerfile syntax highlighting colors */
        .token.keyword {
            color: #63b3ed !important; /* Blue for keywords like FROM, RUN */
        }
        
        .token.string {
            color: #68d391 !important; /* Green for strings */
        }
        
        .token.comment {
            color: #a0aec0 !important; /* Gray for comments */
        }
        
        .token.operator {
            color: #f6ad55 !important; /* Orange for operators */
        }
        
        .token.punctuation {
            color: #cbd5e0 !important; /* Light gray for punctuation */
        }
        
        /* Additional token types for better coverage */
        .token.builtin,
        .token.symbol,
        .token.constant {
            color: #fbb6ce !important; /* Pink for built-in values */
        }
        
        .token.function,
        .token.class-name {
            color: #faf089 !important; /* Yellow for functions/commands */
        }
        
        .token.number {
            color: #fc8181 !important; /* Red for numbers */
        }
        
        .token.boolean {
            color: #f6ad55 !important; /* Orange for booleans */
        }
        
        .token.variable {
            color: #81e6d9 !important; /* Cyan for variables */
        }
        
        /* Fallback for any unspecified text */
        .language-dockerfile *,
        .language-bash * {
            color: #e2e8f0 !important; /* Light gray fallback */
        }
        
        /* Ensure plain text in code blocks is readable */
        pre[class*="language-"] *:not([class*="token"]) {
            color: #e2e8f0 !important;
        }
        
        /* Inline code styling */
        :not(pre) > code {
            background: #4a5568 !important;
            color: #e2e8f0 !important;
            padding: 0.2rem 0.4rem !important;
            border-radius: 3px !important;
            font-size: 0.875em !important;
        }
    </style>
</head>

<body>
    <section class="s1">
        <div class="main-container">
            <div class="intro-wrapper">
                <div class="nav-wrapper">
                    <div class="dots-wrapper">
                        <div id="dot1" class="browser-dot"></div>
                        <div id="dot2" class="browser-dot"></div>
                        <div id="dot3" class="browser-dot"></div>
                    </div>

                    <ul id="navigation">
                        <li><a href="../../index.html">Home</a></li>
                        <li><a href="../../blog.html">Blog</a></li>
                        <li><a href="../../index.html#contact">Contact</a></li>
                    </ul>
                </div>

                <div class="left-column">
                    <h5 style="text-align: center; line-height: 0;">Personalize Your Theme</h5>
                    <div id="theme-options-wrapper">
                        <div data-mode="light" data-text="Default" data-icon="/images/Switch_icon.svg" id="light-mode" class="theme-dot"></div>
                        <div data-mode="nes" data-text="NES" data-icon="/images/NES_icon.svg" id="nes-mode" class="theme-dot"></div>
                        <div data-mode="snes" data-text="SNES" data-icon="/images/SNES_icon.svg" id="snes-mode" class="theme-dot"></div>
                        <div data-mode="n64" data-text="N64" data-icon="/images/N64_icon.svg" id="n64-mode" class="theme-dot"></div>
                    </div>
                    <div id="theme-text"></div>
                    <img id="theme-icon" src="/images/Switch_icon.svg">
                    <p id="settings-note">*Your theme settings will be remembered for your next visit.</p>
                </div>

                <div class="right-column">
                    <div id="preview-shadow">
                        <div id="preview">
                            <div id="corner-tl" class="corner"></div>
                            <div id="corner-tr" class="corner"></div>
                            <h3>Blog Post</h3>
                            <p>Deep dive into building reproducible development environments with Docker.</p>
                            <div id="corner-br" class="corner"></div>
                            <div id="corner-bl" class="corner"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="s2">
        <div class="main-container">
            <article class="blog-post-full">
                <header class="post-header">
                    <h1>Docker-first local development: building reproducible development environments</h1>
                    <div class="post-meta">
                        <time datetime="2025-08-14">August 14, 2025</time>
                        <span class="tags">Docker, DevOps, Development Environment</span>
                    </div>
                </header>

                <div class="post-content">
                    <h2>Problem</h2>
                    
                    <p>A fine line separates our local machines from being the birthplace of innovation or the graveyard of well-intentioned projects. Given the high stakes, it is relatively strange that most developers and organizations don't make local development a significant priority. To make my point, see how well you relate to these struggles:</p>

                    <ol>
                        <li>You were diligent and documented your setup perfectly in your README... six months ago. Now half the steps are wrong, and you're debugging your own instructions on a new machine.</li>
                        <li>Your code runs flawlessly locally. Yet you'll spend half your development cycle deploying and debugging in a production like environment (or let's be honest... in production).</li>
                        <li>A new team member joins. Day one becomes week one as they navigate undocumented dependencies, missing environment variables, and must meditate on the sisyphean reality of onboarding, intimated as "oh yeah, you also need to install..."</li>
                        <li>You feel it is time to return to that world changing project you stopped working on for some unknown reason. But you spend the first hour trying to figure out how to get it to run, dooming its already uncertain revival for a new, better project that you definitely won't abandon.</li>
                        <li>You enter negotiations with the devil himself to keep your outdated laptop alive rather than give in to that scheduled company upgrade because migrating is an unthinkable land mine you'd end up fruitlessly navigating. Besides, it's not like you've been using soul once since LLMs came around.</li>
                        <li>Your team is now evenly split between silicon and intel processor users. Therefore, it is time to give your stakeholders the bad news that you are shutting down the service because on-call support is officially impossible. It was a good run.</li>
                    </ol>

                    <p>Years of debugging convoluted local systems has given me a couple of core principles:</p>

                    <ul>
                        <li>Automation is the preventative medicine against the disease that is technical debt.</li>
                        <li>Executable documentation is among the only documentation you can consistently rely on.</li>
                    </ul>

                    <h2>TL;DR: The 5-step process</h2>

                        <p>Here's what we'll build to solve these development environment headaches:</p>

                        <ol>
                            <li>Create a personalized base image with your preferred tools, shell configurations, and dotfiles.</li>
                            <li>Build project-specific containers that extend your base image with only the tools needed for that project.</li>
                            <li>Mount your source code so changes sync instantly between container and host.</li>
                            <li>Use helper scripts to automate the build and run process for one-command setup.</li>
                            <li>Enjoy consistent environments across all projects, team members, and machines.</li>
                        </ol>

                    <h2>The approach: layered docker development</h2>

                    <p>Most Docker development approaches fall into two camps: project-specific containers that rebuild everything from scratch (slow, inconsistent), or heavy pre-built containers that feel generic and impersonal.</p>

                    <p>This article demonstrates a third way: creating a personalized base image with your preferred tools and dotfiles, then extending it for specific projects. This gives you Docker's reproducibility without sacrificing the comfort of your customized environment; the speed of familiar tools with the portability of containers.</p>

                    <p>We won't dive into performance optimization, production deployment, or complex orchestration. Those are important but beyond our scope. Instead, we'll focus on building a template for consistent, reproducible development environments that feel as comfortable as your native setup.</p>

                    <h2>Prerequisites</h2>

                        <p>You'll need:</p>

                        <ul>
                            <li>Docker installed and running.</li>
                            <li>Some Docker familiarity (comfortable with <code>docker build</code> and <code>docker run</code>).</li>
                            <li>Basic command line skills (running commands, navigating directories).</li>
                        </ul>

                        <p>Helpful but not required: organized dotfiles (we'll breifly cover dotfile setup later).</p>
                    
                    <h2>The brass tacks of Docker-based development</h2>

                    <p>Let's outline the advantages and challenges we'll face with this proposed methodology.</p>

                    <h3>Advantages</h3>

                    <ul>
                        <li>Your local development container more closely mirrors production containers than your bespoke local development setup.</li>
                        <li>Docker gives us much better reproducibility. We should expect commands like <code>docker build</code>, <code>docker run</code>, and <code>docker-compose up</code> to work consistently across machines.</li>
                        <li>We can achieve a self-documenting workflow since our dependencies are explicitly declared in Dockerfiles.</li>
                        <li>Multiple projects with conflicting dependencies can coexist peacefully.</li>
                        <li>We have a version controlled development environment because the whole setup is now code.</li>
                    </ul>

                    <h3>Challenges</h3>

                    <ul>
                        <li>Volume mounts can be slower than native file access.</li>
                        <li>Container debugging requires basic Linux skills. (but come on... you should have/want those).</li>
                        <li>Containers are ephemeral; customizations need persistence strategies.</li>
                        <li>We need to manage IDE integration complexity. Modern IDEs handle this better, but setup remains non-trivial.</li>
                    </ul>

                    <h2>Building your development foundation</h2>

                    <p>The key to this approach is creating a carefully crafted base image with your preferred tools, then extending it for specific projects rather than starting fresh each time. We'll mount source code into containers while keeping it accessible to local IDEs—changes in either location sync instantly.</p>


                    <h3>A quick aside on managing dotfiles</h3>

                    <p>I want to make a suggestion on a prerequisite that will make our containers come pre-configured with our current local environment's preferred tooling and settings.</p>

                    <p>That reccomendation is for the tool <a href="https://www.gnu.org/software/stow/">stow</a> to assist with dotfile management. Check my referenced sources at the end of this article if you want to learn more about <code>stow</code>. All we need to understand now is that <code>stow</code> manages our dotfiles (i.e. <code>.zshrc</code>, <code>.vim</code>, etc.) in a dedicated "dotfiles" directory that symlinks to our home directory.</p>

                    <p>This is useful to us because Docker can only access files in its "build context" (the directory where you run <code>docker build</code>). Having a common place for our dotfiles, means that we can easily copy our dotfiles into a project's given "build context".</p>

                    <p>So after using stow, my home directory looks something like this:</p>

<pre><code class="language-bash">/home/user
├── .bash_history
├── .bash_logout
├── .bashrc -> dotfiles/.bashrc # notice the symlink
├── .bashrc.bak
├── .config -> dotfiles/.config # notice the symlink
├── Desktop
├── Documents
├── dotfiles
│   ├── .bashrc
│   ├── .config
│   ├── .gitignore
│   ├── .oh-my-zsh
│   ├── README.md
│   └── .zshrc
├── .gitconfig
├── Music
├── .oh-my-zsh -> dotfiles/.oh-my-zsh # notice the symlink
├── Pictures
├── Projects
├── Public
├── .ssh # this is a dotfile, but we don't want to be copying .ssh keys
├── .zcompdump # Don't need to stow this either. Just for caching to improve startup time.
├── .zsh_history # No need to stow this unless keeping your command history saved is useful to you
├── .zshrc -> dotfiles/.zshrc # notice the symlink
└── .zshrc.pre-oh-my-zsh -> dotfiles/.zshrc</code></pre>

                    <p>Notice that my dotfiles are in a shared directory called "dotfiles" and are being symlinked back to my <code>$HOME</code>.</p>

                    <h3>Our <code>dev-base</code> container</h3>

                    <p>Let's talk about our <code>dev-base</code> image that will bring our local preferred tools and settings into our project's containers.</p>

                    <p>First things first, we'll create a Dockerfile with a preferred image. I tend to work out of Debian, so I develop most of my projects in a Debian environment, but this base image can be set to match whatever your preferred or required environment is.</p>

                    <p>We do this by defining our <code>FROM</code> command like so:</p>

<pre><code class="language-dockerfile">FROM debian:bookworm-slim</code></pre>

                    <p>For our base image to be useful, we need to install our preferred development tools so we don't manually have to replicate these preferences across every development container.</p>

                    <p>Many of these tools may already come pre-installed on your image, but it doesn't hurt to specify them for the sake of clarity. Here's an example:</p>

<pre><code class="language-dockerfile">RUN apt-get update && apt-get install -y \
    git \
    curl \
    wget \
    zsh \
    vim \
    nano \
    build-essential \
    unzip \
    ca-certificates \
    sudo \
    htop \
    tree \
    jq \
    openssh-client \
    gnupg2 \
    less \
    netcat-openbsd \
    dnsutils \
    ripgrep \
    fd-find \
    && rm -rf /var/lib/apt/lists/*</code></pre>

                    <p>I am installing things like <code>tree</code>, <code>htop</code> <code>zsh</code>, and <code>vim</code> which are tools I use frequently and want to have access to in all of my development environments.</p>

                    <p>Next, we should create a non-root user to avoid permission issues with mounted volumes:</p>

<pre><code class="language-dockerfile">ARG USERNAME=devuser
# UID 1000 typically matches the first user on Linux systems
ARG USER_UID=1000
ARG USER_GID=$USER_UID

RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt" > /etc/sudoers.d/$USERNAME</code></pre>

                    <p>We can switch to our user context in our Dockerfile for user-specific installations in their home directory.</p>

                    <p>For example, I prefer developing with an add-on to my <code>zsh</code> terminal called <code>oh-my-zsh</code> among other popular plugins and themes for my shell.</p>

<pre><code class="language-dockerfile">USER $USERNAME
WORKDIR /home/$USERNAME

# Install oh-my-zsh
RUN sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# Install popular zsh plugins
RUN git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions \
    && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

# Install Spaceship theme
RUN git clone https://github.com/spaceship-prompt/spaceship-prompt.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt --depth=1 \
    && ln -s ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt/spaceship.zsh-theme ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship.zsh-theme</code></pre>

                    <p>With this, we can expect our workspace to have our preferred terminal setup.</p>
                    <p>Next, let's copy in our dotfiles with our preferred settings and configurations for our tools. Note, that in this Dockerfile we are making an assumption that our "dotfiles" directory is in the same directory with our Dockerfile. A reminder from earlier that Docker cannot copy something outside of its context space.</p>

                    <p>In a shell script that we'll review later, we'll manage the copying and cleaning up of our dotfiles into the directory where our base Dockerfile is.</p>

<pre><code class="language-dockerfile">
# These are just two examples of configurations I want copied in. 
# I don't need every dotfile, but as time passes and my tooling changes, 
# I can always add additional COPY lines for future dotfiles.
COPY --chown=$USERNAME:$USERNAME dotfiles/.zshrc /home/$USERNAME/.zshrc
COPY --chown=$USERNAME:$USERNAME dotfiles/.vimrc /home/$USERNAME/.vimrc</code></pre>

<p>Lastly, we need to set up a workspace directory where our project will live when we mount it to this container. Since we've configured zsh with oh-my-zsh and our preferred plugins, let's also set it as our default shell.</p>
<pre><code class="language-dockerfile">RUN mkdir -p /home/$USERNAME/workspace

WORKDIR /home/$USERNAME/workspace

CMD ["/bin/zsh"]</code></pre>

                    <p>The whole thing will look like this:</p>

<pre><code class="language-dockerfile">FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    git \
    curl \
    wget \
    zsh \
    vim \
    nano \
    build-essential \
    unzip \
    ca-certificates \
    sudo \
    htop \
    tree \
    jq \
    openssh-client \
    gnupg2 \
    less \
    netcat-openbsd \
    dnsutils \
    ripgrep \
    fd-find \
    && rm -rf /var/lib/apt/lists/*

ARG USERNAME=devuser
ARG USER_UID=1000
ARG USER_GID=$USER_UID

RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt" > /etc/sudoers.d/$USERNAME

USER $USERNAME
WORKDIR /home/$USERNAME

# Install oh-my-zsh
RUN sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# Install popular zsh plugins
RUN git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions \
    && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

# Install Spaceship theme for terminal
RUN git clone https://github.com/spaceship-prompt/spaceship-prompt.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt --depth=1 \
    && ln -s ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt/spaceship.zsh-theme ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship.zsh-theme

COPY --chown=$USERNAME:$USERNAME dotfiles/.zshrc /home/$USERNAME/.zshrc
COPY --chown=$USERNAME:$USERNAME dotfiles/.vimrc /home/$USERNAME/.vimrc

RUN mkdir -p /home/$USERNAME/workspace

WORKDIR /home/$USERNAME/workspace

CMD ["/bin/zsh"]</code></pre>

                    <p>To be good stewards of this beautiful Dockerfile we've created, and to fulfill our mandate of "executable documentation", let's manage the building and configuring of the image with a bash script (rather than some instructions in a README).</p>

                    <p>We need our script to do the following:</p>

                    <ol>
                        <li>Copy our "dotfiles" directory into our local directory so our Dockerfile's <code>COPY</code> command will work as intended.</li>
                        <li>Build our docker image so other containers can later pull from this local image.</li>
                        <li>Clean up our temporary dotfiles directory.</li>
                    </ol>

                    <p>Here's my version of the <code>build.sh</code> script:</p>

<pre><code class="language-bash">#!/bin/bash

set -euo pipefail

# Check if DOTFILES_DIR env variable is set, if not prompt user
if [[ -z "${DOTFILES_DIR:-}" ]]; then
    read -p "Enter dotfiles directory path: " -r DOTFILES_DIR
    DOTFILES_DIR="${DOTFILES_DIR/#\~/$HOME}"
    export DOTFILES_DIR
fi

if [[ ! -d "$DOTFILES_DIR" ]]; then
    echo "Error: Dotfiles directory not found: $DOTFILES_DIR" >&2
    exit 1
fi

echo "Using dotfiles from: $DOTFILES_DIR"

trap "rm -rf ./dotfiles" EXIT

cp -rT "$DOTFILES_DIR" "./dotfiles"

# Build the image, passing DOTFILES_DIR as build argument
BUILD_DATE=$(date +%Y%m%d)
docker build -f Dockerfile.base \
  -t dev-base:latest \
  -t dev-base:$BUILD_DATE .

echo "✅ Built dev-base:latest and dev-base:$BUILD_DATE"

echo "cleaning up temp dotfiles directory"</code></pre>

                    <p>After running, we have this <code>dev-base</code> image on our local machines which future project specific images can extend.</p>

<pre><code class="language-bash">➜ docker images
REPOSITORY   TAG        IMAGE ID       CREATED         SIZE
dev-base     20250802   6351a5d71ff7   3 minutes ago   612MB
dev-base     latest     6351a5d71ff7   3 minutes ago   612MB</code></pre>

<div class="screenshot-comparison">
    <h3>Before and after: basic container vs. enahnced dev-base</h3>
    <p>Let's see the difference between a basic Debian container and our personalized dev-base:</p>
    
    <div class="comparison-images">
        <img src="./images/basic-container-terminal.png" alt="Basic Debian container with plain bash prompt" />
        <img src="./images/enhanced-container-terminal.png" alt="Enhanced dev-base container with oh-my-zsh and custom theme" />
    </div>
    
    <p><em>Above: Basic debian:bookworm-slim container with minimal tools. Below: Our personalized dev-base with oh-my-zsh, custom theme, and familiar configurations. Notice the immediate difference in prompt, available tools, and overall feel.</em></p>
</div>

                    <p>Now let's go through a few example projects that can build on top of this base image.</p>

                    <h2>Example: LaTeX development (why the base image matters)</h2>

                    <p>Here's a real-world example where Docker converts a painful setup into a clean, self-documented, and version controlled onboarding process.</p>

                    <p>I chose LaTeX screenplay writing, not because it's common, but because it illustrates the kind of specialized development environment that would normally require:</p>

                    <ul>
                        <li>Manual download and installation of obscure packages.</li>
                        <li>Knowledge of TeX directory structures.</li>
                        <li>System-specific configuration that varies between macOS/Linux/WSL.</li>
                        <li>Documentation that inevitably goes stale.</li>
                    </ul>

                    <p>This is where containerization pays significant dividends. What would normally be an arduous setup becomes a simple matter of executing a <code>docker run</code> command.</p>

<pre><code class="language-dockerfile">FROM dev-base:latest

USER root

RUN apt-get update && apt-get install -y \
    pandoc \
    texlive-latex-base \
    texlive-latex-extra \
    texlive-fonts-recommended \
    texlive-latex-recommended \
    && rm -rf /var/lib/apt/lists/*

# Install screenplay package from the official source
RUN cd /tmp && \
    # Download the screenplay package
    wget http://dvc.org.uk/sacrific.txt/screenplay.zip && \
    echo "8ec5210bcd4d3c2a7d961f4a9a7472c9fea8a7b00907dc7601465a947413a265  screenplay.zip" | sha256sum -c - && \
    unzip screenplay.zip && \
    # Generate the class files using the provided installer
    latex screenplay.ins && \
    # Create the correct directory where TeX looks for local packages
    mkdir -p /usr/local/share/texmf/tex/latex/screenplay && \
    # Copy the generated files to the correct location
    cp screenplay.cls /usr/local/share/texmf/tex/latex/screenplay/ && \
    cp hardmarg.sty /usr/local/share/texmf/tex/latex/screenplay/ && \
    # Update the TeX filename database for the local tree
    mktexlsr /usr/local/share/texmf && \
    # Copy example files to permanent location
    mkdir -p /usr/local/share/screenplay-examples && \
    cp example.tex test.tex /usr/local/share/screenplay-examples/

# Verify installation works by testing if TeX can find the class
RUN kpsewhich screenplay.cls

# Create an entrypoint script that copies examples directory and starts bash
RUN echo '#!/bin/bash' > /usr/local/bin/entrypoint.sh && \
    echo 'cp -r /usr/local/share/screenplay-examples /home/devuser/workspace/ 2>/dev/null || true' >> /usr/local/bin/entrypoint.sh && \
    echo 'exec "$@"' >> /usr/local/bin/entrypoint.sh && \
    chmod +x /usr/local/bin/entrypoint.sh


USER devuser
WORKDIR /home/devuser/workspace

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["/bin/zsh"]</code></pre>

                    <p>Notice how this Dockerfile starts with <code>FROM dev-base:latest</code>. This means:</p>

                    <ul>
                        <li>No reinstalling basic tools - git, vim, zsh, and all your dotfiles are already there.</li>
                        <li>We hav a consistent environment where every project feels familiar because they share the same foundation.</li>
                        <li>Because we're only adding LaTeX-specific dependencies and not rebuilding your entire development environment, we should have a faster build.</li>
                    </ul>

                    <p>For improved "executable documentation", we can then add a simple <code>run-dev.sh</code> script that will build and run our project for us.</p>

<pre><code class="language-bash">#!/bin/bash

# Build the image
docker build -t screenplay-latex .

# Run container with interactive terminal and volume mounting
# Notice that we're mounting to the workspace directory we set 
# up in the base image
docker run -it --rm -v "$(pwd):/home/devuser/workspace" screenplay-latex</code></pre>

                    <p>This complex LaTeX setup is now portable and reusable. What was once a fragile, machine-specific configuration is captured in code and builds consistently anywhere.</p>

                    <p>This same pattern works for any specialized environment, whether it's a legacy Python version, a specific Node.js setup, or even more unconventional requirements.</p>


<div class="screenshot-single">
    <h3>LaTeX environment ready to use</h3>
    <img src="./images/latex-container-demo.png" alt="LaTeX container showing successful screenplay compilation" />
    <p><em>Complex LaTeX setup with specialized packages working immediately.</em></p>
</div>

<p><a href="./images/example-screenplay.pdf" target="_blank">View the compiled screenplay PDF</a> that was generated from this containerized environment.</p>

                    <h2>A more common example: web development</h2>

                    <p>Let's see how this base image approach applies to a more typical development scenario, a simple web development environment with Node.js tooling.</p>

<pre><code class="language-dockerfile">FROM dev-base:latest

USER root

RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# Install web development tools globally
RUN npm install -g \
    http-server \
    live-server \
    prettier

# Copy entrypoint script that starts web server and keeps container running
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

# Copy helper script for common development tasks
COPY webdev-helper.sh /usr/local/bin/webdev
RUN chmod +x /usr/local/bin/webdev

USER devuser
WORKDIR /home/devuser/workspace

# Expose ports for web servers
EXPOSE 8000 8080

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["tail", "-f", "/dev/null"]</code></pre>

                    <p>Here are the base script and the referenced helper scripts from the webdev Dockerfile:</p>

                    <h3><code>run-dev.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash

# Stop and remove any existing container first
echo "Cleaning up existing container..."
docker stop web-dev-container 2>/dev/null || true
docker rm web-dev-container 2>/dev/null || true

# Build the development image
echo "Building web development container..."
if ! docker build -f Dockerfile.dev -t web-dev:latest .; then
    echo "Build failed! Exiting..." >&2
    exit 1
fi

# Debug: Show what we're mounting
echo "================================================================"
echo "Current directory: $(pwd)"
echo "Files in current directory:"
ls -la
echo "================================================================"

echo "Starting web development container..."
echo "Access your site at:"
echo "  - http://localhost:8000 (basic server)"
echo "  - http://localhost:8080 (live-reload server)"
echo ""
echo "To access the container shell:"
echo "  docker exec -it web-dev-container /bin/zsh"
echo ""
echo "Inside the container, use:"
echo "  webdev live    # Start live-reload server"
echo "  webdev serve   # Start basic server"  
echo "  webdev format  # Format your code"
echo "================================================================"

# Run container with volume mounting
if ! docker run -d \
  --name web-dev-container \
  -p 8000:8000 \
  -p 8080:8080 \
  -v "$(pwd):/home/devuser/workspace" \
  web-dev:latest; then
    echo "Failed to start container! Exiting..." >&2
    exit 1
fi

echo "Container started! Basic server running on port 8000."
echo ""
echo "Verify the mount worked:"
echo "  docker exec web-dev-container ls -la /home/devuser/workspace"
echo ""
echo "Access the shell:"
echo "  docker exec -it web-dev-container /bin/zsh"</code></pre>

                    <h3><code>entrypoint.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash
echo "=== Web Development Container ==="
echo "Starting Node.js HTTP server on port 8000..."
echo "Access your site at: http://localhost:8000"

cd /home/devuser/workspace
http-server -p 8000 --host 0.0.0.0 &
SERVER_PID=$!

cleanup() {
    kill $SERVER_PID 2>/dev/null || true
    exit 0
}
trap cleanup SIGINT SIGTERM

exec "$@"</code></pre>

                    <h3><code>webdev-helper.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash
case "$1" in
  "serve")
    echo "Starting http-server on port 8000..."
    http-server -p 8000 --host 0.0.0.0
    ;;
  "live")
    echo "Starting live-server with auto-reload..."
    live-server --port=8080 --host=0.0.0.0
    ;;
  "format")
    echo "Formatting HTML, CSS, and JS files..."
    prettier --write "**/*.{html,css,js,json}"
    ;;
  "validate")
    echo "Validating JSON files..."
    find . -name "*.json" -exec jq . {} \;
    ;;
  *)
    echo "Usage: webdev {serve|live|format|validate}"
    echo "  serve    - Start http-server on port 8000"
    echo "  live     - Start live-server with auto-reload on port 8080"
    echo "  format   - Format HTML/CSS/JS files with Prettier"
    echo "  validate - Validate JSON files"
    ;;
esac</code></pre>

<h2>Key takeaways</h2>

<p>Remember those core principles from the beginning?</p>

<ul>
    <li><strong>"Automation is the preventative medicine against the disease that is technical debt"</strong> — Your <code>run-dev.sh</code> scripts automate the entire environment setup, preventing the accumulation of undocumented steps.</li>
    <li><strong>"Executable documentation is among the only documentation you can consistently rely on"</strong> — Your Dockerfiles <em>are</em> your documentation. They can't go stale because they're executed every time someone builds the project.</li>
</ul>

<p>This base image approach delivers on those principles while solving our original problems:</p>

<ol>
    <li><strong>No more stale READMEs</strong> — The Dockerfile is the single source of truth for dependencies.</li>
    <li><strong>No more "works on my machine"</strong> — Everyone runs the exact same container.</li>
    <li><strong>No more painful onboarding</strong> — New team members run <code>./run-dev.sh</code> and they're ready.</li>
    <li><strong>No more abandoned projects</strong> — Return to any project and it runs exactly as you left it.</li>
    <li><strong>No more machine migration dread</strong> — Your entire environment rebuilds identically on any machine.</li>
</ol>

<p>The magic isn't just in the containers, it's in treating your development environment as code. Your Dockerfiles and scripts aren't just configurations; they're living, executable documentation that proves itself correct every time it runs.</p>
                    <h2>Additional material and references</h2>

                    <ul>
                        <li><a href="https://tamerlan.dev/how-i-manage-my-dotfiles-using-gnu-stow/">How I manage my dotfiles using GNU Stow.</a></li>
                        <li><a href="https://www.paolomainardi.com/posts/docker-performance-macos/">Docker on MacOS is slow and how to fix it.</a></li>
                        <li><a href="https://www.howtogeek.com/i-run-a-full-linux-desktop-in-docker-just-because-i-can/">I Run a Full Linux Desktop in Docker Just Because I Can.</a></li>
                    </ul>

                    <div class="post-footer">
                        <p><em>Have questions about Docker development environments or want to share your own setup? <a href="/index.html#contact">Get in touch</a> - I'd love to hear about your experiences with containerized development.</em></p>
                    </div>
                </div>
            </article>
        </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script type="text/javascript" src="/scripts/setThemeForGivenDotClick.js"></script>
    <script type="text/javascript" src="/scripts/setHoverOnDotEffects.js"></script>
</body>

</html>