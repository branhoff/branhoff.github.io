<!DOCTYPE html>
<html>

<head>
    <title>Docker-first local development: building reproducible development environments - Brandon Hoffman</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&family=Russo+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/themes/default.css">
    <link id="theme-style" rel="stylesheet" type="text/css" href="">
    <!-- Add Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Custom styling for code blocks to ensure good contrast */
        pre[class*="language-"] {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            border-radius: 6px;
            padding: 1rem !important;
            margin: 1rem 0 !important;
            overflow-x: auto;
        }
        
        code[class*="language-"] {
            color: #e2e8f0 !important;
            background: transparent !important;
        }
        
        /* Dockerfile syntax highlighting colors */
        .token.keyword {
            color: #63b3ed !important; /* Blue for keywords like FROM, RUN */
        }
        
        .token.string {
            color: #68d391 !important; /* Green for strings */
        }
        
        .token.comment {
            color: #a0aec0 !important; /* Gray for comments */
        }
        
        .token.operator {
            color: #f6ad55 !important; /* Orange for operators */
        }
        
        .token.punctuation {
            color: #cbd5e0 !important; /* Light gray for punctuation */
        }
        
        /* Additional token types for better coverage */
        .token.builtin,
        .token.symbol,
        .token.constant {
            color: #fbb6ce !important; /* Pink for built-in values */
        }
        
        .token.function,
        .token.class-name {
            color: #faf089 !important; /* Yellow for functions/commands */
        }
        
        .token.number {
            color: #fc8181 !important; /* Red for numbers */
        }
        
        .token.boolean {
            color: #f6ad55 !important; /* Orange for booleans */
        }
        
        .token.variable {
            color: #81e6d9 !important; /* Cyan for variables */
        }
        
        /* Fallback for any unspecified text */
        .language-dockerfile *,
        .language-bash * {
            color: #e2e8f0 !important; /* Light gray fallback */
        }
        
        /* Ensure plain text in code blocks is readable */
        pre[class*="language-"] *:not([class*="token"]) {
            color: #e2e8f0 !important;
        }
        
        /* Inline code styling */
        :not(pre) > code {
            background: #4a5568 !important;
            color: #e2e8f0 !important;
            padding: 0.2rem 0.4rem !important;
            border-radius: 3px !important;
            font-size: 0.875em !important;
        }
    </style>
</head>

<body>
    <section class="s1">
        <div class="main-container">
            <div class="intro-wrapper">
                <div class="nav-wrapper">
                    <div class="dots-wrapper">
                        <div id="dot1" class="browser-dot"></div>
                        <div id="dot2" class="browser-dot"></div>
                        <div id="dot3" class="browser-dot"></div>
                    </div>

                    <ul id="navigation">
                        <li><a href="../../index.html">Home</a></li>
                        <li><a href="../../blog.html">Blog</a></li>
                        <li><a href="../../index.html#contact">Contact</a></li>
                    </ul>
                </div>

                <div class="left-column">
                    <h5 style="text-align: center; line-height: 0;">Personalize Your Theme</h5>
                    <div id="theme-options-wrapper">
                        <div data-mode="light" data-text="Default" data-icon="../../images/Switch_icon.svg" id="light-mode" class="theme-dot"></div>
                        <div data-mode="nes" data-text="NES" data-icon="../../images/NES_icon.svg" id="nes-mode" class="theme-dot"></div>
                        <div data-mode="snes" data-text="SNES" data-icon="../../images/SNES_icon.svg" id="snes-mode" class="theme-dot"></div>
                        <div data-mode="n64" data-text="N64" data-icon="../../images/N64_icon.svg" id="n64-mode" class="theme-dot"></div>
                    </div>
                    <div id="theme-text"></div>
                    <img id="theme-icon" src="../../images/Switch_icon.svg">
                    <p id="settings-note">*Your theme settings will be remembered for your next visit.</p>
                </div>

                <div class="right-column">
                    <div id="preview-shadow">
                        <div id="preview">
                            <div id="corner-tl" class="corner"></div>
                            <div id="corner-tr" class="corner"></div>
                            <h3>Blog Post</h3>
                            <p>Deep dive into building reproducible development environments with Docker.</p>
                            <div id="corner-br" class="corner"></div>
                            <div id="corner-bl" class="corner"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="s2">
        <div class="main-container">
            <article class="blog-post-full">
                <header class="post-header">
                    <h1>Docker-first local development: building reproducible development environments</h1>
                    <div class="post-meta">
                        <time datetime="2025-08-14">August 14, 2025</time>
                        <span class="tags">Docker, DevOps, Development Environment</span>
                    </div>
                </header>

                <div class="post-content">
                    <h2>Problem</h2>
                    
                    <p>A fine line separates our local machines from being the birthplace of innovation or the graveyard of well-intentioned projects. Given the high stakes, it is relatively strange that most developers and organizations don't make local development a significant priority. To make my point on the ubiquity of poor local development practices, see how well you relate to these struggles:</p>

                    <ol>
                        <li>You were diligent and documented your setup perfectly in your README... six months ago. Now half the steps are wrong, and you're debugging your own instructions on a new machine.</li>
                        <li>Your code runs flawlessly locally. Yet you'll spend half your development cycle deploying and debugging in a production like environment (or let's be honest... in production).</li>
                        <li>A new team member joins. Day one becomes week one as they navigate undocumented dependencies, missing environment variables, and the new member must meditate on the sisyphean reality of onboarding, so succinctly intimated as "oh yeah, you also need to install..."</li>
                        <li>You feel it is time to return to that world changing project you stopped working on for some unknown reason. But you spend the first hour trying to figure out how to get it to run, dooming its already uncertain revival for a new, better project that you definitely won't abandon.</li>
                        <li>You enter negotiations with the devil himself to keep your unnervingly hot, hissing, and outdated laptop alive rather than give in to accepting that scheduled company upgrade because migrating to a new machine is an unthinkable land mine you'd end up fruitlessly navigating. Besides, you haven't used your soul once since LLMs came around.</li>
                        <li>Your team is now evenly split between silicon and intel processor users. Therefore it is time to give your users the bad news that you are shutting down the service because consistent on-call support is officially impossible. It was a good run.</li>
                    </ol>

                    <p>Years of debugging convoluted local systems has given me a couple of core principles:</p>

                    <ul>
                        <li>Automation is the preventative medicine against the disease that is technical debt.</li>
                        <li>Executable documentation is among the only documentation you can consistently rely on.</li>
                    </ul>

                    <h2>TL;DR: The 5-step process</h2>

                        <p>Here's what we'll build to solve these development environment headaches:</p>

                        <ol>
                            <li>Create a personalized base image with your preferred tools, shell configurations, and dotfiles</li>
                            <li>Build project-specific containers that extend your base image with only the tools needed for that project</li>
                            <li>Mount your source code so changes sync instantly between container and host</li>
                            <li>Use helper scripts to automate the build and run process for one-command setup</li>
                            <li>Enjoy consistent environments across all projects, team members, and machines</li>
                        </ol>

                    <h2>What this article covers (and what it doesn't)</h2>

                    <p>This article demonstrates a specific approach to local development that tries to address the reproducibility and onboarding problems outlined above.</p>

                    <p>In this article I hope to give you an overview of:</p>

                    <ol>
                        <li>Running your development tools inside Docker containers rather than installing them natively</li>
                        <li>Creating a personalized development foundation that you can extend for any project</li>
                    </ol>

                    <h3>What we won't cover</h3>

                    <p>This isn't a comprehensive Docker guide. I won't dive deep into performance optimization, production deployment strategies, or complex multi-service orchestration. Those are important topics, but they're beyond this article's scope.</p>

                    <h3>The goal</h3>

                    <p>By the end of this article, you'll have a template for creating consistent, reproducible development environments that feel as comfortable as your native setup while being significantly more portable.</p>

                    <h2>Requirements of an ideal solution</h2>

                    <p>We face a fundamental tension as software engineers: we want the speed and ease of developing locally on our machines while also wanting to maintain parity with production environments to minimize deployment snafus.</p>

                    <p>We could write our software inside of a dedicated cloud-based development space. But we'll likely run into the headwinds of a slower connection, additional cloud fees, and a more cumbersome setup.</p>

                    <p>If we manage our local development by installing all of our preferred and required tools manually, we're maximizing flexibility and speed, but it is challenging to replicate and we'll eventually hit most of the problems we outlined above.</p>

                    <p>My proposal then is an approach that tries to minimize these tradeoffs and strikes a balance between convenience and parity. Namely, using docker containers on our local machines with a few additional strategies to give us that tailored local development feel we do our best work in while solving the local issues we've mostly accepted begrudgingly drudging through.</p>

                    <h2>Prerequisites</h2>

                        <p>You'll need:</p>

                        <ul>
                            <li>Docker installed and running</li>
                            <li>Some Docker familiarity (comfortable with <code>docker build</code> and <code>docker run</code>)</li>
                            <li>Basic command line comfort (running commands, navigating directories)</li>
                        </ul>

                        <p>Helpful but not required: organized dotfiles (we'll cover dotfile setup if needed).</p>
                    
                    <h2>The brass tacks of Docker-based development</h2>

                    <p>Let's outline the advantages and challenges we'll face with this proposed methodology.</p>

                    <h3>Advantages</h3>

                    <ul>
                        <li>Your local development container more closely mirrors production containers than your bespoke local development setup.</li>
                        <li>Docker gives us much better reproducibility. We should expect commands like <code>docker build</code>, <code>docker run</code>, and <code>docker-compose up</code> to work identically across machines.</li>
                        <li>We can achieve a self-documenting workflow since our dependencies are explicitly declared in Dockerfiles.</li>
                        <li>Multiple projects with conflicting dependencies can coexist peacefully.</li>
                        <li>We have a version controlled development environment because the whole setup is now code.</li>
                    </ul>

                    <h3>Challenges</h3>

                    <ul>
                        <li>Volume mounts can be slower than native file access.</li>
                        <li>Container debugging requires basic Linux skills. (but come on... you should have/want those).</li>
                        <li>Containers are ephemeral; customizations need persistence strategies.</li>
                        <li>We need to manage IDE integration complexity. Modern IDEs handle this better, but setup remains non-trivial.</li>
                    </ul>

                    <h2>How we can minimize the challenges and maximize the advantages?</h2>

                    <p>Most Docker development approaches fall into two camps:</p>

                    <ul>
                        <li>Project-specific containers that rebuild everything from scratch (slow, inconsistent tooling)</li>
                        <li>Heavy, pre-built dev containers that include everything but feel generic</li>
                    </ul>

                    <p>This approach tries to split the difference by creating a personalized base image with your preferred tools and configurations, then extending it for specific projects. This gives you:</p>

                    <ul>
                        <li>The speed and familiarity of your customized environment</li>
                        <li>The reproducibility and portability of containers</li>
                        <li>A pattern that scales across any number of projects</li>
                    </ul>

                    <p>Rather than choosing between convenience and consistency, we can combine Docker's reproducibility with local development's convenience through a few strategic design choices:</p>

                    <ol>
                        <li>Use a carefully crafted base image with your preferred tools, extending it for specific projects rather than starting fresh each time.</li>
                        <li>Mount your source code into containers while keeping it accessible to local IDEs. Changes in either location sync instantly.</li>
                    </ol>

                    <h3>A quick aside on managing dotfiles</h3>

                    <p>I want to make an aside/suggestion on a prerequisite that will make our containers come pre-configured with our local environment's preferred tooling and settings is to have good dotfile management.</p>

                    <p>Namely, my recommendation for the tool <a href="https://www.gnu.org/software/stow/">stow</a>. I won't go into detail about how to set this up or use this tool, but, in a nutshell we want to keep our dotfiles (<code>.zshrc</code>, <code>.vim</code>, etc.) in a dotfiles directory that symlinks to our home directory.</p>

                    <p>This is because Docker can only access files in its "build context" (the directory where you run <code>docker build</code>). This is why we need to copy dotfiles into our project directory temporarily. Having a common place for our dotfiles, means that we can copy these dotfiles consistently.</p>

                    <p>So after using stow, my home directory looks something like this:</p>

<pre><code class="language-bash">/home/user
├── .bash_history
├── .bash_logout
├── .bashrc -> dotfiles/.bashrc # notice the symlink
├── .bashrc.bak
├── .config -> dotfiles/.config # notice the symlink
├── Desktop
├── Documents
├── dotfiles
│   ├── .bashrc
│   ├── .config
│   ├── .gitignore
│   ├── .oh-my-zsh
│   ├── README.md
│   └── .zshrc
├── .gitconfig
├── Music
├── .oh-my-zsh -> dotfiles/.oh-my-zsh # notice the symlink
├── Pictures
├── Projects
├── Public
├── .ssh # this is a dotfile, but we don't want to be copying .ssh keys
├── .zcompdump # Don't need to stow this either. Just for caching to improve startup time.
├── .zsh_history # No need to stow this unless keeping your command history saved is useful to you
├── .zshrc -> dotfiles/.zshrc # notice the symlink
└── .zshrc.pre-oh-my-zsh -> dotfiles/.zshrc</code></pre>

                    <p>Notice that my dotfiles are in a shared directory and being symlinked back to my <code>$HOME</code>. What's nice about this is that I can easily reference and pull in my preferred configurations to my base development container because they're all in a common directory.</p>

                    <h3>Our <code>dev-base</code> container</h3>

                    <p>Now let's talk about our <code>dev-base</code> image that will bring our local preferred tools and settings into our project's containers.</p>

                    <p>First things first, we'll create a Dockerfile with a preferred image. I tend to work out of Debian, so I develop most of my projects in a Debian environment, but this base image can be set to match whatever your preferred or required environment is.</p>

                    <p>We do this by defining our <code>FROM</code> command like so:</p>

<pre><code class="language-dockerfile">FROM debian:bookworm-slim</code></pre>

                    <p>Next, we want our base image to be useful by installing our preferred development tools that we don't want to have to manually replicate across every development container.</p>

                    <p>Many of these tools may already come pre-installed on your image, but it doesn't hurt to specify them for the sake of clarity. Here's an example:</p>

<pre><code class="language-dockerfile">RUN apt-get update && apt-get install -y \
    git \
    curl \
    wget \
    zsh \
    vim \
    nano \
    build-essential \
    unzip \
    ca-certificates \
    sudo \
    htop \
    tree \
    jq \
    openssh-client \
    gnupg2 \
    less \
    netcat-openbsd \
    dnsutils \
    ripgrep \
    fd-find \
    && rm -rf /var/lib/apt/lists/*</code></pre>

                    <p>You can see that I am installing things like <code>tree</code>, <code>htop</code> <code>zsh</code>, and <code>vim</code> which are tools I use frequently and want to have access to in all of my development environments.</p>

                    <p>Next we should create a non-root user to avoid permission issues with mounted volumes:</p>

<pre><code class="language-dockerfile">ARG USERNAME=devuser
# UID 1000 typically matches the first user on Linux systems
ARG USER_UID=1000
ARG USER_GID=$USER_UID

RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt" > /etc/sudoers.d/$USERNAME</code></pre>

                    <p>For additional installations, we can switch to our user in our base Dockerfile.</p>

                    <p>For example, I prefer developing with an add-on to my <code>zsh</code> terminal called <code>oh-my-zsh</code> among other popular plugins and themes for my shell. These are examples of the kind of tooling I don't want to install and reconfigure every time I set up a new Debian based project.</p>

                    <p>Now my preferred fonts, themes, and tools are installed every time I use an image that draws from this base.</p>

<pre><code class="language-dockerfile">USER $USERNAME
WORKDIR /home/$USERNAME

# Install oh-my-zsh
RUN sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# Install popular zsh plugins
RUN git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions \
    && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

# Install Spaceship theme
RUN git clone https://github.com/spaceship-prompt/spaceship-prompt.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt --depth=1 \
    && ln -s ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt/spaceship.zsh-theme ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship.zsh-theme</code></pre>

                    <p>Now let's copy in our dotfiles with our preferred settings and configurations. Note, that in our Dockerfile we are making an assumption that our dotfiles directory is in the same directory with our Dockerfile. A reminder from earlier that Docker cannot copy something outside of its context space.</p>

                    <p>In a shell script that we'll review later, we'll manage the copying and cleaning up of our dotfiles into the directory where our base Dockerfile is.</p>

<pre><code class="language-dockerfile">
# These are just two examples of configurations I want copied in. 
# I don't need every dotfile, but as time passes and my tooling changes, 
# I can always add additional COPY lines for future dotfiles.
COPY --chown=$USERNAME:$USERNAME dotfiles/.zshrc /home/$USERNAME/.zshrc
COPY --chown=$USERNAME:$USERNAME dotfiles/.vimrc /home/$USERNAME/.vimrc</code></pre>

                    <p>Lastly, we just need to set our working directory and our preferred shell. Given all of the related configs, I want <code>zsh</code> as my default terminal.</p>

<pre><code class="language-dockerfile">RUN mkdir -p /home/$USERNAME/workspace

WORKDIR /home/$USERNAME/workspace

CMD ["/bin/zsh"]</code></pre>

                    <p>The whole thing will look like this:</p>

<pre><code class="language-dockerfile">FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    git \
    curl \
    wget \
    zsh \
    vim \
    nano \
    build-essential \
    unzip \
    ca-certificates \
    sudo \
    htop \
    tree \
    jq \
    openssh-client \
    gnupg2 \
    less \
    netcat-openbsd \
    dnsutils \
    ripgrep \
    fd-find \
    && rm -rf /var/lib/apt/lists/*

ARG USERNAME=devuser
ARG USER_UID=1000
ARG USER_GID=$USER_UID

RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && echo "$USERNAME ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt" > /etc/sudoers.d/$USERNAME

USER $USERNAME
WORKDIR /home/$USERNAME

# Install oh-my-zsh
RUN sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended

# Install popular zsh plugins
RUN git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions \
    && git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting

# Install Spaceship theme for terminal
RUN git clone https://github.com/spaceship-prompt/spaceship-prompt.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt --depth=1 \
    && ln -s ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship-prompt/spaceship.zsh-theme ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/spaceship.zsh-theme

COPY --chown=$USERNAME:$USERNAME dotfiles/.zshrc /home/$USERNAME/.zshrc
COPY --chown=$USERNAME:$USERNAME dotfiles/.vimrc /home/$USERNAME/.vimrc

RUN mkdir -p /home/$USERNAME/workspace

WORKDIR /home/$USERNAME/workspace

CMD ["/bin/zsh"]</code></pre>

                    <p>Now, let's be good stewards of this beautiful Dockerfile we've created and manage the creation and setup with a bash script. This also further fulfills our principle of executable code being superior documentation than straight text in a README.</p>

                    <p>We need our script to do the following:</p>

                    <ol>
                        <li>Copy our dotfiles directory into our Dockerfile's local directory</li>
                        <li>Build our docker image so other containers can pull from this local image</li>
                        <li>Clean up our temporary dotfiles directory.</li>
                    </ol>

                    <p>I won't go through a full walkthrough, but here's my version of the script:</p>

<pre><code class="language-bash">#!/bin/bash

set -euo pipefail

# Check if DOTFILES_DIR env variable is set, if not prompt user
if [[ -z "${DOTFILES_DIR:-}" ]]; then
    read -p "Enter dotfiles directory path: " -r DOTFILES_DIR
    DOTFILES_DIR="${DOTFILES_DIR/#\~/$HOME}"
    export DOTFILES_DIR
fi

if [[ ! -d "$DOTFILES_DIR" ]]; then
    echo "Error: Dotfiles directory not found: $DOTFILES_DIR" >&2
    exit 1
fi

echo "Using dotfiles from: $DOTFILES_DIR"

trap "rm -rf ./dotfiles" EXIT

cp -rT "$DOTFILES_DIR" "./dotfiles"

# Build the image, passing DOTFILES_DIR as build argument
BUILD_DATE=$(date +%Y%m%d)
docker build -f Dockerfile.base \
  -t dev-base:latest \
  -t dev-base:$BUILD_DATE .

echo "✅ Built dev-base:latest and dev-base:$BUILD_DATE"

echo "cleaning up temp dotfiles directory"</code></pre>

                    <p>Now We have this dev-base image on our local machines, and future development containers can build on top of this.</p>

<pre><code class="language-bash">➜ docker images
REPOSITORY   TAG        IMAGE ID       CREATED         SIZE
dev-base     20250802   6351a5d71ff7   3 minutes ago   612MB
dev-base     latest     6351a5d71ff7   3 minutes ago   612MB</code></pre>

<div class="screenshot-comparison">
    <h3>Before and after: basic container vs. enahnced dev-base</h3>
    <p>Let's see the difference between a basic Debian container and our personalized dev-base:</p>
    
    <div class="comparison-images">
        <img src="./images/basic-container-terminal.png" alt="Basic Debian container with plain bash prompt" />
        <img src="./images/enhanced-container-terminal.png" alt="Enhanced dev-base container with oh-my-zsh and custom theme" />
    </div>
    
    <p><em>Above: Basic debian:bookworm-slim container with minimal tools. Below: Our personalized dev-base with oh-my-zsh, custom theme, and familiar configurations. Notice the immediate difference in prompt, available tools, and overall feel.</em></p>
</div>

                    <p>Now let's go through a few example projects that can build on top of this base image.</p>

                    <h2>Example: LaTeX development (why the base image matters)</h2>

                    <p>Here's a real-world example where Docker converts a painful setup into a clean, self-documented, and version controlled onboarding process.</p>

                    <p>I chose LaTeX screenplay writing deliberately, not because it's common, but because it illustrates the kind of specialized development environment that would normally require:</p>

                    <ul>
                        <li>Manual download and installation of obscure packages</li>
                        <li>Knowledge of TeX directory structures</li>
                        <li>System-specific configuration that varies between macOS/Linux/WSL</li>
                        <li>Documentation that inevitably goes stale</li>
                    </ul>

                    <p>This is exactly where containerization pays significant dividends. What would normally be an arduous setup with moments of confusion and bewilderment becomes a simple matter of executing a <code>docker run</code> command.</p>

<pre><code class="language-dockerfile">FROM dev-base:latest

USER root

RUN apt-get update && apt-get install -y \
    pandoc \
    texlive-latex-base \
    texlive-latex-extra \
    texlive-fonts-recommended \
    texlive-latex-recommended \
    && rm -rf /var/lib/apt/lists/*

# Install screenplay package from the official source
RUN cd /tmp && \
    # Download the screenplay package
    wget http://dvc.org.uk/sacrific.txt/screenplay.zip && \
    echo "8ec5210bcd4d3c2a7d961f4a9a7472c9fea8a7b00907dc7601465a947413a265  screenplay.zip" | sha256sum -c - && \
    unzip screenplay.zip && \
    # Generate the class files using the provided installer
    latex screenplay.ins && \
    # Create the correct directory where TeX looks for local packages
    mkdir -p /usr/local/share/texmf/tex/latex/screenplay && \
    # Copy the generated files to the correct location
    cp screenplay.cls /usr/local/share/texmf/tex/latex/screenplay/ && \
    cp hardmarg.sty /usr/local/share/texmf/tex/latex/screenplay/ && \
    # Update the TeX filename database for the local tree
    mktexlsr /usr/local/share/texmf && \
    # Copy example files to permanent location
    mkdir -p /usr/local/share/screenplay-examples && \
    cp example.tex test.tex /usr/local/share/screenplay-examples/

# Verify installation works by testing if TeX can find the class
RUN kpsewhich screenplay.cls

# Create an entrypoint script that copies examples directory and starts bash
RUN echo '#!/bin/bash' > /usr/local/bin/entrypoint.sh && \
    echo 'cp -r /usr/local/share/screenplay-examples /home/devuser/workspace/ 2>/dev/null || true' >> /usr/local/bin/entrypoint.sh && \
    echo 'exec "$@"' >> /usr/local/bin/entrypoint.sh && \
    chmod +x /usr/local/bin/entrypoint.sh


USER devuser
WORKDIR /home/devuser/workspace

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["/bin/zsh"]</code></pre>

                    <p>Notice how this Dockerfile starts with <code>FROM dev-base:latest</code>. This means:</p>

                    <ul>
                        <li>No reinstalling basic tools - git, vim, zsh, and all your dotfiles are already there</li>
                        <li>Consistent environment - every project feels familiar because they share the same foundation</li>
                        <li>Faster builds - we're only adding LaTeX-specific dependencies, not rebuilding your entire development environment</li>
                    </ul>

                    <p>Compare this to starting from <code>debian:bookworm-slim</code> every time - you'd be reinstalling oh-my-zsh, copying dotfiles, and configuring your shell for every single project.</p>

                    <p>For improved "executable documentation", We can then add a basic <code>run-dev.sh</code> shell script that will build and run our project for us.</p>

<pre><code class="language-bash">#!/bin/bash

# Build the image
docker build -t screenplay-latex .

# Run container with interactive terminal and volume mounting
docker run -it --rm -v "$(pwd):/home/devuser/workspace" screenplay-latex</code></pre>

                    <p>This complex LaTeX setup is now completely portable and reusable. What was once a fragile, machine-specific configuration is captured in code and builds identically anywhere.</p>

                    <p>This same pattern works for any specialized environment, whether it's a legacy Python version, a specific Node.js setup, or even more unconventional requirements.</p>


<div class="screenshot-single">
    <h3>LaTeX environment ready to use</h3>
    <img src="./images/latex-container-demo.png" alt="LaTeX container showing successful screenplay compilation" />
    <p><em>Complex LaTeX setup with specialized packages working immediately.</em></p>
</div>

<p>What would have taken hours of debugging package installations, TeX directory structures, and system-specific configurations is now a simple <code>docker run</code> command. The screenplay package, all dependencies, and example files are ready to use immediately.</p>

<p><strong>See it in action:</strong> <a href="./images/example-screenplay.pdf" target="_blank">View the compiled screenplay PDF</a> that was generated from this containerized environment.</p>

                    <h2>A more common example: web development</h2>

                    <p>Let's see how this base image approach applies to a more typical development scenario, a simple web development environment with Node.js tooling.</p>

<pre><code class="language-dockerfile">FROM dev-base:latest

USER root

RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# Install web development tools globally
RUN npm install -g \
    http-server \
    live-server \
    prettier

# Copy entrypoint script that starts web server and keeps container running
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

# Copy helper script for common development tasks
COPY webdev-helper.sh /usr/local/bin/webdev
RUN chmod +x /usr/local/bin/webdev

USER devuser
WORKDIR /home/devuser/workspace

# Expose ports for web servers
EXPOSE 8000 8080

ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
CMD ["tail", "-f", "/dev/null"]</code></pre>

                    <p>Here are the base script and the referenced helper scripts from the webdev Dockerfile:</p>

                    <h3><code>run-dev.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash

# Stop and remove any existing container first
echo "Cleaning up existing container..."
docker stop web-dev-container 2>/dev/null || true
docker rm web-dev-container 2>/dev/null || true

# Build the development image
echo "Building web development container..."
if ! docker build -f Dockerfile.dev -t web-dev:latest .; then
    echo "Build failed! Exiting..." >&2
    exit 1
fi

# Debug: Show what we're mounting
echo "================================================================"
echo "Current directory: $(pwd)"
echo "Files in current directory:"
ls -la
echo "================================================================"

echo "Starting web development container..."
echo "Access your site at:"
echo "  - http://localhost:8000 (basic server)"
echo "  - http://localhost:8080 (live-reload server)"
echo ""
echo "To access the container shell:"
echo "  docker exec -it web-dev-container /bin/zsh"
echo ""
echo "Inside the container, use:"
echo "  webdev live    # Start live-reload server"
echo "  webdev serve   # Start basic server"  
echo "  webdev format  # Format your code"
echo "================================================================"

# Run container with volume mounting
if ! docker run -d \
  --name web-dev-container \
  -p 8000:8000 \
  -p 8080:8080 \
  -v "$(pwd):/home/devuser/workspace" \
  web-dev:latest; then
    echo "Failed to start container! Exiting..." >&2
    exit 1
fi

echo "Container started! Basic server running on port 8000."
echo ""
echo "Verify the mount worked:"
echo "  docker exec web-dev-container ls -la /home/devuser/workspace"
echo ""
echo "Access the shell:"
echo "  docker exec -it web-dev-container /bin/zsh"</code></pre>

                    <h3><code>entrypoint.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash
echo "=== Web Development Container ==="
echo "Starting Node.js HTTP server on port 8000..."
echo "Access your site at: http://localhost:8000"

cd /home/devuser/workspace
http-server -p 8000 --host 0.0.0.0 &
SERVER_PID=$!

cleanup() {
    kill $SERVER_PID 2>/dev/null || true
    exit 0
}
trap cleanup SIGINT SIGTERM

exec "$@"</code></pre>

                    <h3><code>webdev-helper.sh</code></h3>

<pre><code class="language-bash">#!/bin/bash
case "$1" in
  "serve")
    echo "Starting http-server on port 8000..."
    http-server -p 8000 --host 0.0.0.0
    ;;
  "live")
    echo "Starting live-server with auto-reload..."
    live-server --port=8080 --host=0.0.0.0
    ;;
  "format")
    echo "Formatting HTML, CSS, and JS files..."
    prettier --write "**/*.{html,css,js,json}"
    ;;
  "validate")
    echo "Validating JSON files..."
    find . -name "*.json" -exec jq . {} \;
    ;;
  *)
    echo "Usage: webdev {serve|live|format|validate}"
    echo "  serve    - Start http-server on port 8000"
    echo "  live     - Start live-server with auto-reload on port 8080"
    echo "  format   - Format HTML/CSS/JS files with Prettier"
    echo "  validate - Validate JSON files"
    ;;
esac</code></pre>

                    <h2>Key takeaways</h2>

                    <p>This base image approach solves the core problems we identified:</p>

                    <ol>
                        <li>Your base image is version-controlled and identical across machines</li>
                        <li>New team members run one script and get your exact development environment</li>
                        <li>Conflicting dependencies can't interfere with each other</li>
                        <li>Every container feels like your personalized development machine</li>
                    </ol>

                    <p>Build your own <code>dev-base</code> image with your preferred tools, then extend it for your next project. You'll immediately feel the difference in setup time and environment consistency.</p>

                    <p>Once this pattern clicks, explore docker-compose for multi-service projects and performance optimizations for your specific platform.</p>

                    <h2>Additional material and references</h2>

                    <ul>
                        <li><a href="https://tamerlan.dev/how-i-manage-my-dotfiles-using-gnu-stow/">How I manage my dotfiles using GNU Stow</a></li>
                        <li><a href="https://www.paolomainardi.com/posts/docker-performance-macos/">Docker on MacOS is slow and how to fix it</a></li>
                    </ul>

                    <div class="post-footer">
                        <p><em>Have questions about Docker development environments or want to share your own setup? <a href="../../index.html#contact">Get in touch</a> - I'd love to hear about your experiences with containerized development.</em></p>
                    </div>
                </div>
            </article>
        </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script type="text/javascript" src="../../scripts/setThemeForGivenDotClick.js"></script>
    <script type="text/javascript" src="../../scripts/setHoverOnDotEffects.js"></script>
</body>

</html>